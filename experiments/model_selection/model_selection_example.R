devtools::load_all()
library(caret)

# Find Criterion
get_criterion_factory <- function(Y,X, method="BIC", family="gaussian"){
  if(method=="BIC"){
    get_criterion <- function(models){
      crit <- apply(models, 1, function(model) BIC(glm(Y~0 + X[, model,drop=F], family=family)))
      list(crit=crit)
    }
  }
  return(get_criterion)
}


# ensemble method for model selection generated by the GLLVM model

# function to return the models that perform best, return only unique models
# M : matrix of models
# TODO: TEST whether the crit is deterministic! it needs to be ! e.g. CV with same seed
# we want to have the LOWEST VALUE HERE

get_best_models <- function(crit.value, M, n){
  ord <- order(crit.value)

  keep.id <- 1:n
  keep.id[1] <- ord[1]
  # loop through all the models until M is filled with unique models or we're out of models to check
  # index the number of retained unique models
  j <- 2
  for(i in 2:nrow(M)){
    # check if 2 models are the same (thus have same crit.value)
    if(crit.value[ord[i]]==crit.value[ord[i-1]]){
      # check if it indeed the same model
      if(all.equal(M[ord[i],], M[ord[i-1],])){
        next()
      } else {
        keep.id[j] <- ord[i]
        j <- j + 1
      }
    } else {
      keep.id[j] <- ord[i]
      j <- j + 1
    }
    if(j==(n+1)) break()
  }

  if(j!=(n+1)) warning(paste0("Could not find ", n, " different models."))
  list(M=M[keep.id,], crit.value=crit.value[keep.id])
}



# Function trying to maximize a criterion
# init must be a list with all the useful quantities...
modelselec <- function(Y, X, family="gaussian", get_criterion=get_criterion_factory(Y, X, method="BIC", family=family), mod.gen=100, mod.keep=20, init=NULL, iter=100, prop.active.init=0.2){
  p <- ncol(X)

  # initial model totally random...
  M <- t(sapply(1:(mod.gen*10), function(na){
    s <- sample(p, sample(min(n, p) * prop.active.init ,1), replace=F)
    (1:p) %in% s
  }))
  BIC <- BIC0 <- get_criterion(M)$crit

  # take the mod.keep best
  Mbest <- get_best_models(BIC, M, mod.keep)
  M <- Mbest$M
  BIC <- Mbest$crit

  #initial gllmvm fit:  TODO: why add a row of ones here?!
  gllvm.fit <- bernoulli.estimate.ffa(rbind(1, M), q=q, reps=2, iter=100, compute.Q=F, verbose=F)

  BIC.hist <- matrix(0, iter, mod.keep)
  M.hist <- matrix(0, iter*p, mod.keep)

  for(i in 1:iter){
    par <- gllvm.fit$par

    M.old <- M
    BIC.old <- BIC

    #TODO: here we remove the intercept....
    par$B <- rep(0, p)

    M <- gen_gllvm(mod.gen, par=par, family="bernoulli")$Y > 0
    M <- M[rowSums(M)< (min(p, n)) & rowSums(M) >1, ]
    BIC <- get_criterion(M)$crit

    # take the mod.keep best
    Mbest <- get_best_models(c(BIC.old, BIC), rbind(M.old, M), mod.keep)
    M <- Mbest$M
    BIC <- Mbest$crit

    M.hist[p*(i-1) + (1:p),] <- M
    BIC.hist[i,] <- BIC

    # # keep the mod.keep best of all last models (maybe more?)
    # M.best <- rbind(M.best, M)
    # BIC.best <- c(BIC.best, BIC)
    # Best.id <- order(BIC.best)[1:(mod.keep*(1+i *2/10))]  # increase the set of best models as we go
    # M.best <- M.best[Best.id,]
    # BIC.best <- BIC.best[Best.id]

    # par(mfrow=c(1,3))
    # boxplot(BIC)
    # plot(gllvm.fit$B, beta)
    # boxplot(rowSums(M))
    # par(mfrow=c(1,1))

    # update the fit based on the BEST OF ALL TIME, not just the last ones ?
    # a <- rep(T, p)
    # a[1:(p/2)] <- F
    # b <- !a
    gllvm.fit <- bernoulli.estimate.ffa(M, q=q, A.init = par$A, B.init=par$B, reps=1, iter=2, verbose=F, tol=-1)

    # print some stuff
    cat("\niter:", i, "BIC reached:", min(BIC), " worst: ", max(BIC))
  }
  list(Best=M, BIC.hist = BIC.hist, par=gllvm.fit$par)
}


# Generate some data
set.seed(2131)
n <- 500
p <- 100
q <- 1
beta01 <- c(rep(-2,4), rep(2,4), rep(0, p-8))
beta02 <- c(rep(0, 8), beta01)[1:p]
model.true <- t(beta01 != 0)

X01 <- matrix(rnorm(n*p), n, p)
X02 <- matrix(rnorm(n*p), n, p)
Y01 <- rbinom(n, 1, 1/(1+exp(-X01 %*% beta01)))
Y02 <- rbinom(n, 1, 1/(1+exp(-X02 %*% beta02)))

X0 <- rbind(X01, X02)
Y0 <- c(Y01, Y02)


# add another half from another model
family <- binomial(link = "logit")

get_criterion <- get_criterion_factory(Y0, X0, method="BIC", family=family)
BIC.true <- get_criterion(model.true)$crit

selec <- modelselec(Y0, X0, mod.gen = 50, mod.keep=500, prop.active.init = .2, family=family)

boxplot(t(selec$BIC.hist)[,1:68], main="boxplots of BICs as a function of passes")
abline(h=BIC.true, col=2)
plot(colMeans(selec$Best))

par <- selec$par
